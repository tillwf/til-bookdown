[["index.html", "Table of contents", " Table of contents Data Engineering Machine Learning "],["data-engineering.html", "1 Data Engineering", " 1 Data Engineering "],["how-to-deploy-an-huggingface-model-api-on-google-cloud-function.html", "1.1 How to deploy an HuggingFace model API on Google Cloud Function", " 1.1 How to deploy an HuggingFace model API on Google Cloud Function Create a file main.py like that: from transformers import TFBertForSequenceClassification from transformers import AutoTokenizer import tensorflow as tf model = None tokenizer = None def predict(request): global model global tokenizer if model is None: model = TFBertForSequenceClassification.from_pretrained(&quot;jonaskoenig/xtremedistil-l6-h256-uncased-question-vs-statement-classifier&quot;, cache_dir=&quot;/tmp&quot;) tokenizer = AutoTokenizer.from_pretrained(&quot;jonaskoenig/xtremedistil-l6-h256-uncased-question-vs-statement-classifier&quot;, cache_dir=&quot;/tmp&quot;) params = request.get_json() sentence = params[&quot;description&quot;] predictions = model(**tokenizer(sentence, return_tensors=&quot;tf&quot;)) probabilities = tf.nn.softmax(predictions.logits[0], axis=0).numpy() return { &quot;no_question&quot;: float(probabilities[0]), &quot;question&quot;: float(probabilities[1]) } and a file requirements.txt like that: tensorflow==2.12.0 transformers==4.27.4 "],["filter-in-join-vs-filter-in-where.html", "1.2 Filter in JOIN vs filter in WHERE", " 1.2 Filter in JOIN vs filter in WHERE Init tables library(DBI) db = dbConnect(RSQLite::SQLite(), dbname = &quot;db.sqlite&quot;) CREATE TABLE users AS SELECT 1 AS user_id, DATETIME(&quot;2023-01-01&quot;) AS created_at UNION ALL SELECT 2 AS user_id, DATETIME(&quot;2023-01-02&quot;) AS created_at UNION ALL SELECT 3 AS user_id, DATETIME(&quot;2023-01-03&quot;) AS created_at; CREATE TABLE trackers AS SELECT 1 AS user_id, 1 AS trackable_id, DATETIME(&quot;2023-01-04&quot;) AS created_at UNION ALL SELECT 2 AS user_id, 1 AS trackable_id, DATETIME(&quot;2023-01-02&quot;) AS created_at UNION ALL SELECT 2 AS user_id, 1 AS trackable_id, DATETIME(&quot;2023-01-02&quot;) AS created_at; SELECT * FROM users; Table 1.1: 3 records user_id created_at 1 2023-01-01 00:00:00 2 2023-01-02 00:00:00 3 2023-01-03 00:00:00 SELECT * FROM trackers; Table 1.2: 3 records user_id trackable_id created_at 1 1 2023-01-04 00:00:00 2 1 2023-01-02 00:00:00 2 1 2023-01-02 00:00:00 Simple JOIN SELECT * FROM users u LEFT JOIN trackers t ON u.user_id = t.user_id Table 1.3: 4 records user_id created_at user_id trackable_id created_at 1 2023-01-01 00:00:00 1 1 2023-01-04 00:00:00 2 2023-01-02 00:00:00 2 1 2023-01-02 00:00:00 2 2023-01-02 00:00:00 2 1 2023-01-02 00:00:00 3 2023-01-03 00:00:00 NA NA NA Filter in the WHERE clause SELECT * FROM users u LEFT JOIN trackers t ON u.user_id = t.user_id WHERE DATE(t.created_at) &gt;= DATE(&quot;2023-01-05&quot;, &quot;-10 DAY&quot;) Table 1.4: 3 records user_id created_at user_id trackable_id created_at 1 2023-01-01 00:00:00 1 1 2023-01-04 00:00:00 2 2023-01-02 00:00:00 2 1 2023-01-02 00:00:00 2 2023-01-02 00:00:00 2 1 2023-01-02 00:00:00 You lose the user_id=3 Filter in the JOIN clause SELECT * FROM users u LEFT JOIN trackers t ON u.user_id = t.user_id AND DATE(t.created_at) &gt;= DATE(&quot;2023-01-05&quot;, &quot;-10 DAY&quot;) Table 1.5: 4 records user_id created_at user_id trackable_id created_at 1 2023-01-01 00:00:00 1 1 2023-01-04 00:00:00 2 2023-01-02 00:00:00 2 1 2023-01-02 00:00:00 2 2023-01-02 00:00:00 2 1 2023-01-02 00:00:00 3 2023-01-03 00:00:00 NA NA NA Adding more filters in the JOIN clause SELECT * FROM users u LEFT JOIN trackers t ON u.user_id = t.user_id AND DATE(t.created_at) &gt;= DATE(&quot;2023-01-05&quot;, &quot;-10 DAY&quot;) AND t.created_at BETWEEN DATETIME(u.created_at, &quot;+ 24 HOUR&quot;) AND DATETIME(u.created_at, &quot;+ 48 HOUR&quot;) Table 1.6: 3 records user_id created_at user_id trackable_id created_at 1 2023-01-01 00:00:00 NA NA NA 2 2023-01-02 00:00:00 NA NA NA 3 2023-01-03 00:00:00 NA NA NA Then you can make an accurate count SELECT u.user_id, CAST(COUNT(DISTINCT t.trackable_id) &gt; 0 AS INT) AS has_action FROM users u LEFT JOIN trackers t ON u.user_id = t.user_id AND DATE(t.created_at) &gt;= DATE(&quot;2023-01-05&quot;, &quot;-10 DAY&quot;) AND t.created_at BETWEEN DATETIME(u.created_at, &quot;+ 24 HOUR&quot;) AND DATETIME(u.created_at, &quot;+ 48 HOUR&quot;) GROUP BY u.user_id Table 1.7: 3 records user_id has_action 1 0 2 0 3 0 If we filter on the users in the JOIN clause SELECT u.user_id, CAST(COUNT(DISTINCT t.trackable_id) &gt; 0 AS INT) AS has_action FROM users u LEFT JOIN trackers t ON u.user_id = t.user_id AND DATE(t.created_at) &gt;= DATE(&quot;2023-01-05&quot;, &quot;-10 DAY&quot;) AND t.created_at BETWEEN DATETIME(u.created_at, &quot;+ 24 HOUR&quot;) AND DATETIME(u.created_at, &quot;+ 48 HOUR&quot;) AND u.user_id = 3 GROUP BY u.user_id Table 1.8: 3 records user_id has_action 1 0 2 0 3 0 If we filter on the users in the WHERE clause SELECT u.user_id, CAST(COUNT(DISTINCT t.trackable_id) &gt; 0 AS INT) AS has_action FROM users u LEFT JOIN trackers t ON u.user_id = t.user_id AND DATE(t.created_at) &gt;= DATE(&quot;2023-01-05&quot;, &quot;-10 DAY&quot;) AND t.created_at BETWEEN DATETIME(u.created_at, &quot;+ 24 HOUR&quot;) AND DATETIME(u.created_at, &quot;+ 48 HOUR&quot;) WHERE u.created_at &gt;= &quot;2023-01-03&quot; GROUP BY u.user_id Table 1.9: 1 records user_id has_action 3 0 "],["machine-learning.html", "2 Machine Learning", " 2 Machine Learning "],["ab-testing.html", "2.1 A/B Testing", " 2.1 A/B Testing "],["xgboost.html", "2.2 XGBoost", " 2.2 XGBoost "],["miscellaneous.html", "3 Miscellaneous", " 3 Miscellaneous "],["movie-clips-blind-test.html", "3.1 Movie Clips Blind Test", " 3.1 Movie Clips Blind Test The goal of this game is to show short clips (~10 secondes) of movies and try to guess the movie list. 3.1.1 Solution 1 Cut every movies into short clips. Put these files into a folder and play files of this folder randomly using any video player. Script to split every movie into equal clips j=0 for i in *.mp4 do ffmpeg -i &quot;$i&quot; \\ -ss 600 \\ -t 3600 \\ -c copy \\ -map 0 \\ -segment_time 00:00:10 \\ -f segment \\ -reset_timestamps 1 res/${j}_%06d.mp4 ((j=j+1)) done Explanation: j=0 This line initializes a variable j to 0. This variable will be used to keep track of the segment number. for i in *.mp4 do This line starts a for loop that iterates over all the MP4 files in the current directory. ffmpeg -i &quot;$i&quot; \\ -ss 600 \\ -t 3600 \\ -c copy \\ -map 0 \\ -segment_time 00:00:10 \\ -f segment \\ -reset_timestamps 1 res/${j}_%06d.mp4 This line uses FFmpeg to split each input MP4 file into 10-second segments. Hereâ€™s what each option does: -i \"$i\" specifies the input file. -ss 600 specifies the start time in seconds. In this case, it starts at 10 minutes (600 seconds) into the video. -t 3600 specifies the duration in seconds. In this case, it extracts 1 hour (3600 seconds) of video. -c copy specifies that the video and audio codecs should be copied without re-encoding. -map 0 specifies that all streams from the input file should be included in the output. -segment_time 00:00:10 specifies the duration of each segment. -f segment specifies the output format as segmented MP4 files. -reset_timestamps 1 specifies that the timestamps of the output segments should be reset to zero. res/${j}_%06d.mp4 specifies the output file name pattern. %06d is a placeholder for the segment number, padded with leading zeros to 6 digits. ${j} is the current value of the variable j. The segments are saved in the res/ directory. ((j=j+1)) This line increments the j variable by 1. In summary, this script splits each MP4 video file in the current directory into 10-second segments starting from the 10th minute of the video and extracts 1 hour of video. The output segments are saved in the res/ directory with a filename pattern that includes the segment number. Plays the video randomly Vlc could be a good solution but between each video the screen flickers and we see the desktop. Instead we will use mpv: find . -iregex &quot;.*\\.\\(mp4\\|flv\\|MOV\\|webm\\|avi\\|mpg\\|mpeg\\)&quot; -type f -exec mpv --fs --shuffle --loop-playlist=inf &quot;{}&quot; + 3.1.2 Solution 2 (to be enhanced) We want to avoid recreating data so we will randomly play part of each movie programmatically using a python (3.10.6) script: import os import random from moviepy.video.io.VideoFileClip import VideoFileClip # Needs to be imported to be able to call the method `preview` from moviepy.editor import * # Set the path to the folder containing the movies path = &quot;.&quot; # Get a list of all the mp4 files in the folder files = [os.path.join(path, f) for f in os.listdir(path) if f.endswith(&quot;.mp4&quot;)] # Preload movie and its duration: data = {} for file in files: print(f&quot;Loading {file}&quot;) clip = VideoFileClip(file) duration = clip.duration data[file] = (clip, duration) # Loop through each movie file and play a random 10-second clip while True: # Choose a file randomly file = random.choice(files) # Load the video file clip clip, duration = data[file] # Set the start time of the clip to a random value between 0 and (duration - 10) start_time = random.uniform(0, duration - 10) # Set the end time of the clip to 10 seconds after the start time end_time = start_time + 10 # Extract the 10-second clip subclip = clip.subclip(start_time, end_time) # Display the clip subclip.preview(fullscreen=True) The requirements are: moviepy==1.0.3 pygame==2.4.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
